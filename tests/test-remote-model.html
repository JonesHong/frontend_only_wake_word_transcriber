<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¸¬è©¦é ç«¯æ¨¡å‹è¼‰å…¥</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .progress {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª æ¸¬è©¦ Whisper é ç«¯æ¨¡å‹è¼‰å…¥</h1>
        
        <div class="test-section">
            <h2>1. æ¸¬è©¦æœ¬åœ°æ¨¡å‹</h2>
            <button id="testLocal" onclick="testLocalModel()">è¼‰å…¥æœ¬åœ°æ¨¡å‹</button>
            <div id="localStatus" class="status info">ç­‰å¾…æ¸¬è©¦...</div>
        </div>
        
        <div class="test-section">
            <h2>2. æ¸¬è©¦é ç«¯æ¨¡å‹</h2>
            <button id="testRemote" onclick="testRemoteModel()">è¼‰å…¥é ç«¯æ¨¡å‹ (Xenova/whisper-tiny)</button>
            <div id="remoteStatus" class="status info">ç­‰å¾…æ¸¬è©¦...</div>
        </div>
        
        <div class="test-section">
            <h2>3. æ¸¬è©¦å¿«å–</h2>
            <button id="testCache" onclick="testCache()">æª¢æŸ¥ IndexedDB å¿«å–</button>
            <div id="cacheStatus" class="status info">ç­‰å¾…æ¸¬è©¦...</div>
        </div>
    </div>

    <script type="module">
        let worker = null;
        
        window.testLocalModel = async function() {
            const button = document.getElementById('testLocal');
            const status = document.getElementById('localStatus');
            
            button.disabled = true;
            status.className = 'status progress';
            status.textContent = 'æ­£åœ¨è¼‰å…¥æœ¬åœ°æ¨¡å‹...';
            
            try {
                // å‰µå»º Worker
                worker = new Worker('/js/workers/whisper.worker.js', { type: 'module' });
                
                // è¨­ç½®è¨Šæ¯è™•ç†
                worker.onmessage = (event) => {
                    const data = event.data;
                    console.log('Worker message:', data);
                    
                    if (data.type === 'modelLoadProgress') {
                        status.textContent = `è¼‰å…¥é€²åº¦: ${data.progress}%\n${data.message}`;
                    } else if (data.type === 'modelLoaded') {
                        status.className = 'status success';
                        status.textContent = `âœ… æœ¬åœ°æ¨¡å‹è¼‰å…¥æˆåŠŸï¼\næ¨¡å‹: ${data.model}\nä¾†æº: ${data.source}`;
                        button.disabled = false;
                    } else if (data.error) {
                        throw new Error(data.error);
                    }
                };
                
                // åˆå§‹åŒ– Worker
                await sendWorkerMessage({
                    type: 'initialize',
                    config: {
                        language: 'zh',
                        task: 'transcribe'
                    }
                });
                
                // è¼‰å…¥æœ¬åœ°æ¨¡å‹
                await sendWorkerMessage({
                    type: 'loadModel',
                    config: {
                        model: 'models/huggingface/Xenova/whisper-base',
                        whisperModelSource: 'local',
                        quantized: false
                    }
                });
                
            } catch (error) {
                status.className = 'status error';
                status.textContent = `âŒ è¼‰å…¥å¤±æ•—: ${error.message}`;
                button.disabled = false;
            }
        };
        
        window.testRemoteModel = async function() {
            const button = document.getElementById('testRemote');
            const status = document.getElementById('remoteStatus');
            
            button.disabled = true;
            status.className = 'status progress';
            status.textContent = 'æ­£åœ¨å¾ Hugging Face è¼‰å…¥é ç«¯æ¨¡å‹...\né¦–æ¬¡è¼‰å…¥å¯èƒ½éœ€è¦å¹¾åˆ†é˜...';
            
            try {
                // å‰µå»ºæ–° Worker
                if (worker) {
                    worker.terminate();
                }
                worker = new Worker('/js/workers/whisper.worker.js', { type: 'module' });
                
                // è¨­ç½®è¨Šæ¯è™•ç†
                worker.onmessage = (event) => {
                    const data = event.data;
                    console.log('Worker message:', data);
                    
                    if (data.type === 'modelLoadProgress') {
                        status.textContent = `è¼‰å…¥é€²åº¦: ${data.progress}%\n${data.message}`;
                    } else if (data.type === 'modelLoaded') {
                        status.className = 'status success';
                        status.textContent = `âœ… é ç«¯æ¨¡å‹è¼‰å…¥æˆåŠŸï¼\næ¨¡å‹: ${data.model}\nä¾†æº: ${data.source}\nå¿«å–: ${data.cached}`;
                        button.disabled = false;
                    } else if (data.error) {
                        throw new Error(data.error);
                    }
                };
                
                // åˆå§‹åŒ– Worker
                await sendWorkerMessage({
                    type: 'initialize',
                    config: {
                        language: 'zh',
                        task: 'transcribe'
                    }
                });
                
                // è¼‰å…¥é ç«¯æ¨¡å‹ï¼ˆä½¿ç”¨è¼ƒå°çš„ tiny æ¨¡å‹é€²è¡Œæ¸¬è©¦ï¼‰
                await sendWorkerMessage({
                    type: 'loadModel',
                    config: {
                        model: 'Xenova/whisper-tiny',
                        whisperModelSource: 'remote',
                        quantized: true
                    }
                });
                
            } catch (error) {
                status.className = 'status error';
                status.textContent = `âŒ è¼‰å…¥å¤±æ•—: ${error.message}`;
                button.disabled = false;
            }
        };
        
        window.testCache = async function() {
            const status = document.getElementById('cacheStatus');
            status.className = 'status progress';
            status.textContent = 'æ­£åœ¨æª¢æŸ¥ IndexedDB å¿«å–...';
            
            try {
                // æ‰“é–‹ IndexedDB
                const databases = await indexedDB.databases();
                const transformersDBs = databases.filter(db => 
                    db.name && db.name.includes('transformers') || 
                    db.name && db.name.includes('onnx')
                );
                
                if (transformersDBs.length > 0) {
                    let cacheInfo = 'æ‰¾åˆ°ä»¥ä¸‹å¿«å–è³‡æ–™åº«:\n';
                    for (const db of transformersDBs) {
                        cacheInfo += `- ${db.name} (ç‰ˆæœ¬: ${db.version})\n`;
                        
                        // å˜—è©¦ç²å–æ›´å¤šè³‡è¨Š
                        try {
                            const openDB = await new Promise((resolve, reject) => {
                                const request = indexedDB.open(db.name);
                                request.onsuccess = () => resolve(request.result);
                                request.onerror = () => reject(request.error);
                            });
                            
                            const objectStoreNames = Array.from(openDB.objectStoreNames);
                            cacheInfo += `  å„²å­˜å€: ${objectStoreNames.join(', ')}\n`;
                            openDB.close();
                        } catch (e) {
                            console.error('Error opening DB:', e);
                        }
                    }
                    
                    status.className = 'status success';
                    status.textContent = `âœ… ${cacheInfo}`;
                } else {
                    status.className = 'status info';
                    status.textContent = 'â„¹ï¸ å°šæœªæ‰¾åˆ°å¿«å–è³‡æ–™åº«ã€‚è¼‰å…¥é ç«¯æ¨¡å‹å¾Œæœƒè‡ªå‹•å»ºç«‹ã€‚';
                }
            } catch (error) {
                status.className = 'status error';
                status.textContent = `âŒ æª¢æŸ¥å¤±æ•—: ${error.message}`;
            }
        };
        
        // Helper function to send messages to worker
        function sendWorkerMessage(message) {
            return new Promise((resolve, reject) => {
                const messageId = Math.random().toString(36).substr(2, 9);
                
                const handler = (event) => {
                    if (event.data.messageId === messageId) {
                        worker.removeEventListener('message', handler);
                        if (event.data.error) {
                            reject(new Error(event.data.error));
                        } else {
                            resolve(event.data);
                        }
                    }
                };
                
                worker.addEventListener('message', handler);
                worker.postMessage({ ...message, messageId });
                
                // Timeout after 60 seconds
                setTimeout(() => {
                    worker.removeEventListener('message', handler);
                    reject(new Error('Worker timeout'));
                }, 60000);
            });
        }
    </script>
</body>
</html>